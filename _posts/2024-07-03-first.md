---
layout: single
title: "TypeScript 기초 이론 정리"
categories: TypeScript
tag: [TS, front-end, 타입스크립트]
sidebar:
    nav: "counts"
---

- 컴파일러: 우리가 작성한 코드를 프로그램 형태로 동작시키기 위해 프로그램이 동작하는 **환경**에서 이해할 수 있는 언어 등으로 변환해줘야 하는 과정
    - statically typed: 컴파일러 시간에 타입이 결정되고 확인됨
    - dynamically typed: Run Time 환경 때 타입이 결정되고 확인됨
- js는 타입이 없어서 가독성이 낮은편 → 변수가 어떤 데이터를 담고있는지, 어떤 인자를 받아서 기능을 수행하는지에 더불어 사용자가 내 어플리케이션을 사용하면서 에러가 터지는 문제가 생길 수 있음
- ts는 내가 개발할 때 실시간으로 에러에 대한 검사를 받을 수 있으므로 안정적이고 확장이 쉬움 + 강력한 객체지향 프로그래밍`(Object-Oriented Programming)`이 가능
    
    <aside>
    💡 OOP의 장점은?
    **모듈성** 있는 프로그램 사용이 가능함
    모듈별로 원하는 것을 **재사용**할 수 있기 때문에 재사용이 높아짐
    **객체 단위로 확장**해나갈 수 있음
    
    ⇒ 기존 코드의 문제 해결이나 기능 추가가 쉬워지면서 **유지보수성**이 좋아짐
    
    </aside>
    
- `tsc -v` 하면 typescript 버전 정보 확인 가능

<aside>
💡 **tsc 파일명.ts**
→ 파일명.js 파일이 만들어짐
**node 파일명.js** 을 통해 실행

</aside>

- **js가 동작할 수 있는 곳에서 ts를 이용할 수 있지만 컴파일러를 이용하여 js로 변환한 후에 사용해야함!!**

- `npm install -g ts-node` → ts코드를 js로 변환해서 node에서 실행하는 것을 한번에 할 수 있도록 함
⇒ `ts-node 파일명.ts` 로 사용하면 터미널에서 바로 결과가 나옴
- type 좀 더 보장되는 방식으로 프로그래밍 하는 것이 중요 → 변수, 클래스, 함수에 어떤 데이터를 전달할 수 있고 어떤 것을 받아올 수 있는지 명확하게 세부적으로 작성하는 것이 중요

## TypeScript 기본 문법

```tsx
{
  /**
   * JavaScript
   * Primitive: number, string, boolean, bigint, symbol, null, undefined
   * Object: function, array
   */

  //TypeScript
  //number 정수, 소수
  const num: number = -5;
  //string
  const str: string = "hello";
  //boolean true, false
  const bool: boolean = false;

  //undefined -> 값이 있는지 없는지 결정안됨
  //null -> 비어있음을 알려줌

  //undefined
  let name: undefined; // 💩
  let age: number | undefined; //보통 이렇게 or 넣어서 데이터가 있을수 있거나 없을 수 있음을 나타냄
  age = undefined;
  age = 6;

  function example(): number | undefined {
    return undefined;
  } //숫자나 undefined을 return하는 함수

  //null
  let person: null; // 💩
  let person2: string | null;

  //unknown -> 어떤 타입의 데이터가 담길지 모를 때 사용 -> 💩 안쓰는게 좋음
  //any -> 어떤 타입이든 담을 수 있는 변수 -> 💩 절대 안쓰는게 좋긴함

  //함수 **void** -> 아무것도 리턴하지 않는 경우!
  function print(): void { //void인 경우 : void 부분 **생략 가능**
    console.log("hello");
    return; //생략 가능
  }
  let unusable: void = undefined; // 💩

  //함수 never -> 리턴하는 값이 절대 없음 (에러를 던지거나 리턴되지 않는 경우->후자의 경우 while(true)일 때)
  function throwError(message: string): never {
    //meesage를 serever로 던져서 로그를 남김
    throw new Error(message);
    //에러를 던지거나 while문으로 끝나지 않게 하는 경우 사용
  }
  let neverEnding: never; // 💩

  //object -> 원시 타입을 제외한 모든 object 타입의 데이터든 담을 수 있음 // 💩 -> 구체적으로 작성해주는게 좋음
  let obj: object;
  function acceptSomeObject(obj: object) {}
  acceptSomeObject({ name: "elice" });
  acceptSomeObject({ age: 6 });
}

```

## TypeScript 함수 기본 문법

- Promise<type>
- Optional parameter ?
- Default parameter

```tsx
{
  //JavaScriipt
  function isAdd(num1, num2) {
    return num1 + num2;
  }

  //TypeScript
  function add(num1: number, num2: number): number {
    //각각 숫자를 전달받아 숫자를 리턴함을 알 수 있음
    return num1 + num2;
  }
  
 ----------------------------------------------------------------------

  //JavaScript
  function jsFetchNum(id) {
    // code ...
    return new Promise((resolve, reject) => {
      resolve(100);
    });
  }

  //TypeScript
  function tsFetchNum(id: string): Promise<number> {
    /*  string 형태의 id를 받아서 Promise를 반환하는데,
    Promise는 fetch가 완료된 후 숫자를 반환하겠구나!를 알 수 있음 */

    //code ...
    return new Promise((resolve, reject) => {
      resolve(100);
    });
  }
  
  ----------------------------------------------------------------------

  // **Optional Parameter** ?는 언제 사용할까 -> 전달받을 수도 있고 전달받지 않을 수도 있을 때
  function printName(firstName: string, lastName?: string) {
    //firstName은 string으로 넘어와야하지만 lastName은 string 형식으로 들어올 수도 있고 들어오지 않을 수도 있음
    console.log(firstName);
    console.log(lastName);
  }

  printName("steve", "jobs");
  printName("hyein");
  printName("Anna", undefined); //undefined도 가능

  //Default Parameter
  function printMessage(message: string = "default message") {
    console.log(message);
  }

  printMessage(); // message를 전달하지 않아도 message의 기본값인 "default message"가 출력됨

  //Rest Parameter
  function addNumber(...number: number[]): number {
    //number라는 배열은 number로만 구성된 배열임
    return number.reduce((a, b) => a + b);
  }

  console.log(addNumber(1, 2, 3, 4)); //10출력됨
}

```

## TypeScript 배열, 튜플

```tsx
{
  //Arrays 표현방법
  const fruits: string[] = ["tomato", "banana"];
  //fruits는 string이라는 타입을 적은 다음에 []를 붙여서 배열임을 표시 가능
  const scores: Array<number> = [1, 3, 4];
  //scores는 숫자를 갖고있는 배열임을 표시 가능
  function printArray(fruits: readonly string[]) {
    //readonly를 붙이면 push등 불가능 -> 오직 읽는 것만 가능!!
    //이처럼 일관성있게 하고 싶을 때 Array<string>이 아니라 string[]꼴로 쓰기도함
  }

  //Tuple -> 배열인데 서로 다른 타입도 선언 가능 , 사용을 권장하지는 않음
  //interface, type alias, class로 대체해서 사용하는게 좋음
  let student: [string, number];
  student = ["name", 123];
  student[0]; // name
  student[1]; // 123
  //이처럼 튜플은 접근하기 번거로우니까 아래처럼 구조분해할당을 해서 사용하기도 함
  const [name, age] = student; //배열 구조분해할당 !== 객체구조분해할당
}

```

## Type Alias

내가 새로운 type을 지정할 수 있음

### String Literal Types

```tsx
{
  /**
   * Type Alias는 내가 새로운 type을 지정할 수 있음
   */
  **type Text = string;**
  const name: Text = "elice";

  type Student = {
    name: string;
    age: number;
  };
  const student: Student = {
    name: "hyein",
    age: 26,
    address: "서울특별시", //해당 type인 Student에 없는 속성을 입력하면 에러가 뜸
  };

  /**
   * String Literal Types
   * 타입을 문자열로도 지정할 수 있음
   */
  type Name = "name";
  let eliceName: Name;
  eliceName = "name";
  eliceName = "other"; //문자열 "name" Name이라는 타입이니까 다른 문자열은 못들어감
}

```

## union

특정 값만 지정하고 싶을 때

```tsx
{
  /**
   * Union Types: OR
   * 특정 값만 지정하고 싶을 때
   */
  type Direction = "right" | "left" | "up" | "down";
  function move(direction: Direction) {
    console.log(direction);
  }

  move("down");
  move("left");
  move("right");
  move("up"); // Direction의 값이 아닌 것은 올 수 없음

  type TitleSize = 3 | 6 | 9;
  const title: TitleSize = 3; //3, 6, 9중 하나니까 가능
  //const titl2: TitleSize = 30;
  //30이라는 값은 TitleSize에 없으니 불가능

  //ex. function: login -> success, fail
  type SuccessState = {
    response: { body: string };
  };
  
  type FalseState = {
    reason: string;
  };
  
  type LoginState = SuccessState | FalseState;

  function login(): LoginState {
    return {
      response: {
        body: "hi",
      },
    };
  }

  //printLoginState(state: LoginState)
  //success -> '성공' 출력
  //fail -> '실패' 출력
  const printLoginState = (state: LoginState) => {
    if ("response" in state) {
      //response라는 키가 state object 안에 있는 경우
      console.log(`성공 ${state.response.body}`);
    } else {
      console.log(`실패 ${state.reason}`);
    }
  };
  //함수 형태로 작성해보기
  function printLoginState2(state: LoginState) {
    if ("response" in state) {
      console.log(`성공 ${state.response.body}`);
    } else {
      console.log(`실패 ${state.reason}`);
    }
  }
  
  // 위 if문을 개선하기 위해서 아래와 같은 **discriminated Union**을 사용
  
  {
  type SuccessState = {
    result: "success";
    response: { body: string };
  };
  type FalseState = {
    result: "fail";
    reason: string;
  };
  type LoginState = SuccessState | FalseState;

  //printLoginSTate(state: LoginState)
  //success -> '성공' 출력
  //fail -> '실패' 출력
  function printLoginState3(state: LoginState) {
    // state.result -> success or fail임을 ts는 알기 때문에 조건으로 가능
    if (state.result === "success") {
      console.log(`성공 ${state.response.body}`);
    } else {
      console.log(`실패 ${state.reason}`);
    }
  }
}

  /////////////  /////////////  /////////////

  //이런건 어떠려나(그냥 혼자 고민해본거임)
  type ResponseState = {
    response: { body: string };
    reason?: string;
  };

  function login2(state: string): ResponseState {
    if (state) {
      return { response: { body: "hi" } };
    } else {
      return { response: { body: "hi" }, reason: "이유" };
    }
  }

  function login3(): LoginState {
    const success = someConditionCheck();
    if (success) {
      return {
        response: {
          body: "hi",
        },
      };
    } else {
      return {
        reason: "Login failed reason",
      };
    }
  }
  function someConditionCheck(): boolean {
    return Math.random() > 0.5;
  }
}

```

- 디스크리미네이드 유니온(discriminated Union)은 유니온 타입을 사용하는 고급 패턴의 일종
- `union`은 발생할 수 있는 모든 케이스 중 한가지만 선택하는 거라면, `Intersection`은 그 모든 것을 합한 성격을 의미
→ union이 or 같은 성격이면 intersection은 and 느낌

## Intersection &

```tsx
{
  /**
   * Intersection Types: &
   */
  type Student = {
    name: string;
    score: number;
  };

  type Worker = {
    employeeId: string;
    work: () => void; //아무런 인자도 받지 않고 아무것도 리턴하지 않음
  };

  //입력 파라미터의 타입 지정
  function internWork(person: Student & Worker) {
    console.log(person.name, person.employeeId, person.work());
    //Student, Worker 모든 것에 접근 가능
  }

  internWork({
    name: "혜인",
    score: 4,
    employeeId: "hyein",
    work: () => {},
  }); //대신 **모든** 데이터가 담겨있는 **object를 전달해야함**

  //cf. 반환 파라미터 지정
   function internWork(): Student & Worker {
  return {
    name: "혜인",
    score: 4,
    employeeId: "hyein",
    work: () => console.log("Working")
  };
}

}

```

## Enum

```tsx
{
  /**
   * Enum -> 여러가지 관련된 상수값을 한 곳에 모아 정리할 수 있게 해줌, ts 자체 제공
   *  => 가능하면 안 쓰는게 좋음(enum으로 타입이 지정된 변수에 어떤 숫자든 할당이 가능해져서)
   */

  //JavaScript
  const MONDAY = 0;
  const TUESDAY = 1;
  const WEDNESDAY = 2;
  const DAYS_ENUM = Object.freeze({ MONDAY: 0, TUESDAY: 1, WEDNESDAY: 2 });
  const dayOfToday = DAYS_ENUM.MONDAY;

  //TypeScrip
  enum DAYS {
    MONDAY, //0
    TUESDAY, //1
    WEDNESDAY, //2 로 값이 자동으로 들어감
    Friday = "friday", //문자열 지정 이후에는 값이 자동으로 안생기므로 따로 지정해줘야함
    Saturday = "saturday",
  }
  const day = DAYS.TUESDAY;
  console.log(day); // 1이 출력됨

  //enum은 String Literal Types으로 대체될 수 있기 때문에 비추!
  type DaysOfWeek = "MONDAY" | "TUESDAY" | "WEDNESDAY";
  let dayOfweek: DaysOfWeek = "MONDAY";
  dayOfweek = "hyein"; //없는 값을 지정하면 type 에러가 뜸. 이게 enum보다 안전하고 좋음
}

```

![enum보단 String Literal Types를 사용](https://prod-files-secure.s3.us-west-2.amazonaws.com/905111a7-f3ba-459a-b7b3-e7a6af27affc/76f94f42-1f9d-4e9d-86d5-16a8089df586/Untitled.png)

enum보단 String Literal Types를 사용

⇒ 즉, `enum`보단 `Union type`이 더 안전함!

---

- type을 따로 명시하지 않으면 `any` 타입이 됨

---

# 객체지향

- 객체지향은 object단위로 만들어감 → 관련된 것만 수정하거나 재사용이 가능
- class는 데이터가 들어있지 않은 템플릿 같은 것 → object는 instance of a class와 같음
- class는 어떻게 생겼는지 명시 → class를 통해 실제 데이터를 넣은 object를 만들 수 있음

## 객체지향 특징

- 캡슐화: 흩어진 애들 중 연관이 있는 애들끼리 묶음 → 서로 관련있는 데이터와 함수를 한 object로 담아두고 외부에서 볼 필요가 없는 데이터를 잘 숨겨둠
- 추상화: 외부에서는 내부가 어떻게 구성이 되어있는지, 얼마나 복잡한지 이해할 필요 없이, 외부에서 보이는 interface를 이용해서 object 사용이 가능함
    - `interface`를 이용하면 추상화를 극대화하여 사용할 수 있음
- 상속
- 다형성

## class

```tsx
{
  type CoffeeCup = {
    shots: number;
    hasMilk: boolean;
  };

  class CoffeeMaker {
    static BEANS_GRAMM_PER_SHOT: number = 7; //class level -> object마다 만들어지거나 생성되지않음
    coffeeBeans: number = 0; //instance level

    constructor(coffeeBeans: number) {
      //constructor는 object를 만들 때 항상 호출됨
      this.coffeeBeans = coffeeBeans;
    }

    static makeMachine(coffeeBeans: number): CoffeeMaker {
      return new CoffeeMaker(coffeeBeans);
    }
    makeCoffee(shots: number): CoffeeCup {
      //class 멤버 변수에 접근할 때는 this를 붙여줘야함
      if (this.coffeeBeans < shots * CoffeeMaker.BEANS_GRAMM_PER_SHOT) {
        //static 변수는 class명 지정해줘야함
        throw new Error("not enough");
      }
      this.coffeeBeans -= shots * CoffeeMaker.BEANS_GRAMM_PER_SHOT;
      return {
        shots: shots, // shots로 생략 가능
        hasMilk: false,
      };
    }
  }

  const maker = new CoffeeMaker(32);
  console.log(maker);

  const maker2 = CoffeeMaker.makeMachine(3); //static이 붙은 메서드는 바로 호출 가능
}

```

## 캡슐화

```tsx
{
  type CoffeeCup = {
    shots: number;
    hasMilk: boolean;
  };

  //public
  //private -> 외부에서 접근이 불가능해짐
  //protected -> 상속시 외부에서는 접근이 안되지만 클래스를 상속한 다른 자식 클래스 내에서는 접근이 가능함
  class CoffeeMaker {
    private static BEANS_GRAMM_PER_SHOT: number = 7;
    private coffeeBeans: number = 0;

    constructor(coffeeBeans: number) {
      this.coffeeBeans = coffeeBeans;
    }

    static makeMachine(coffeeBeans: number): CoffeeMaker {
      return new CoffeeMaker(coffeeBeans);
    }

    fillCoffeeBeans(beans: number) {
      //따로 작성안하면 public이 됨
      if (beans < 0) {
        throw new Error("옳지 않은 값");
      }
      this.coffeeBeans += beans;
    }

    makeCoffee(shots: number): CoffeeCup {
      if (this.coffeeBeans < shots * CoffeeMaker.BEANS_GRAMM_PER_SHOT) {
        throw new Error("not enough");
      }
      this.coffeeBeans -= shots * CoffeeMaker.BEANS_GRAMM_PER_SHOT;
      return {
        shots: shots,
        hasMilk: false,
      };
    }
  }
}

///////// 예시 /////////

class User {
    firsName: string;
    lastName: string;

    get fullName(): string {
      return `${this.firsName} ${this.lastName}`;
    }

    constructor(firstName: string, lastName: string) {
      this.firsName = firstName;
      this.lastName = lastName;
    }
  }
  const user = new User("Steve", "Jobs");
  console.log(user.fullName);
  user.firsName = "hyein"; //setter, getter를 통해 constructor로 고정되었던 값 변경 가능
  console.log(user.fullName);
 
```

---

# 제네릭

## class와 generic

```tsx
interface Either<L, R> {
  //L과 R은 원하는대로 의미가 들어가도록 간략하게 작성
  left: () => L;
  right: () => R;
}

class SimpleEither<L, R> implements Either<L, R> {
  constructor(private leftValue: L, private rightValue: R) {}
  left(): L {
    return this.leftValue;
  }

  right(): R {
    return this.rightValue;
  }
}

const either: Either<number, number> = new SimpleEither(4, 5);
either.left(); //4
either.right(); //5
const best = new SimpleEither(4, "hello"); //어떤 타입이든 쓰는 사람이 결정이 가능해짐

```

## 제네릭 조건

```tsx
interface Employee {
  pay(): void;
}

class FullTimeEmployee implements Employee {
  pay() {
    console.log("full time!");
  }
  workFullTime() {}
}

class PartTimeEmployee implements Employee {
  pay() {
    console.log("part time!");
  }
  workPartTime() {}
}
//Employee를 받아서 월급 지급 후 직원을 다시 리턴함
//세부적인 타입을 인자로 받아서 정말 추상적인 타입으로 다시 리턴하므로 💩
function payBad(employee: Employee): Employee {
  employee.pay();
  return employee;
}

//generic이긴한데 Employee를 확장한 타입만 가능하다라는 의미가 됨
function pay<**T extends Employee**>(employee: T): T {
  employee.pay();
  return employee;
}

const elie = new FullTimeEmployee();
const bob = new PartTimeEmployee();
elie.workFullTime();
bob.workPartTime();

//아래의 elice와 bob은 FullTimeEmployee, PartTimeEmployee 클래스의 인스턴스임
//해당 인스턴스들의 클래스가 'Employee' 인터페이스를 구현하고 있기 때문 -> pay 메서드를 가질 수 있음
const elieAfterPay = payBad(elie);
const bobAfterPay = payBad(bob);
```

⇒ 제네릭 함수 **`pay<T extends Employee>(employee: T): T`**는 **`Employee`** 인터페이스를 확장하는 어떤 타입 **`T`**도 받을 수 있으며, 그 타입 **`T`**의 인스턴스를 인수로 받아 동일한 타입의 인스턴스를 반환

---

# 에러 처리

- exception: 예상할 수 없는 에러
- Error state: 예상할 수 있는 에러

⇒ 두개를 구분해서 사용할 필요가 있음

## Error에 대해

- Error(Exception) Handling: `try → catch → finally`
    - finally는 try, catch 뭐가 실행되든 항상 호출됨
    - TS에서 구현된 catch()에는 어떠한 타입정보도 전달되지 않아서 instanceOf를 사용할 수 없음

---

- type ≠ interface
- interface: object, **object간 의사소통**을 할 때 정해진 interface를 통해 서로 상호작용을 할 수 있도록 하는 계약서와 같음

```tsx
interface Position = {
	x: number;
	y: number;
}
```

- types: 어떠한 데이터를 담을 때, 어떤 데이터를 담을 수 있을지 데이터의 타입을 정해주는 것과 같음
→ 무언가를 구현할 목적이 아니라 **데이터를 담을 목적이 큰 경우**

```tsx
type Position = {
	x: number;
	y: number;
}
```

- utilty type은 변환이 가능함!

## Index Type

- 다른 type에 있는 key에 접근하여 key의 value의 type을 그대로 다시 선언할 수 있음

```tsx
{
  const obj = {
    name: "ellie",
  };
  obj.name; //ellie
  obj["name"]; //ellie

  type Animal = {
    name: string;
    age: number;
    gender: "male" | "female";
  };

  type Name = Animal["name"];
  //Name의 type은 string이 됨 -> 동물에 있는 name이라는 키의 타입을 Name에 선언한거임
  const text: Name = "hello";

  type Gender = Animal["gender"]; //'male' | 'female'

  type Keys = keyof Animal;
  //Animal에 있는 모든 키를 타입으로 할당 -> 'name' | 'age' | 'gender'
  const key: Keys = ''
}

```

![keyof 를 통해 해당 객체에 있는 모든 키를 타입으로 할당할 수 있음]

keyof 를 통해 해당 객체에 있는 모든 키를 타입으로 할당할 수 있음

## Mapped Type

- 기존에 있는 type들을 이용하면서 조금 다른 타입으로 변환이 가능함
- **재사용성**이 굉장히 높아짐

```tsx
{
  type Video = {
    title: string;
    author: string;
  };

  //기본 형식
  type Optional<T> = {
    // 받아온 타입을 통해 map을 사용함
    //T가 갖고있는 key들 중 들어있는 하나의 P는~ 하고 정의 가능
    [P in keyof T]?: T[P]; // for...in
  };

  type VideoOptional = Optional<Video>;
  //Optional에 전달된 Video는 Video의 key들을 돌면서 title, author를 optional로 만들고 형식도 지정해줌

  //사용 예시
  const videoOp: VideoOptional = {
    title: "hi",
    //author는 생략 가능
  };
  // type VideoOptional = {
  //   title?: string;
  //   author?: string;
  // }; 하나하나 다 복사해주려면 힘듦

  type Nullable<T> = { [P in keyof T]: T[P] | null };
  const obj2: Nullable<Video> = {
    title: "hi",
    author: null, //Nullable은 null도 지정을 할 수 있게됨
  };
}

```

## Conditional Type

- ~한 조건을 만족하면 @와같은 type이 됨

```tsx
//Check type이 전달된 type이 string을 상속하면 boolean이 되고 아니면 number의 type을 갖게 됨
type Check<T> = T extends string ? boolean : number;
type Type = Check<string>; //boolean
//Check는 string이 되었으니 Type은 boolean type이 됨
```

## Partial Type

- 기존의 type중에서 **부분적인 것만 허용**하고 싶을 때 이용

```tsx
{
  type ToDo = {
    title: string;
    description: string;
    label: string;
    priority: "high" | "low";
  };

  function updateTodo(todo: ToDo, fieldsToUpdate: Partial<ToDo>): ToDo {
    return { ...todo, ...fieldsToUpdate };
    //기존의 todo에 추가로 업데이트 하고싶은 fieldsToUpdate를 더해서 업데이트
  }

  const todo: ToDo = {
    title: "learn TS",
    description: "content",
    label: "study",
    priority: "high",
  };
  const updated = updateTodo(todo, { priority: "low" });
  console.log(updated); //priority만 low로 변경되어 출력됨
}

```

## Pick type

- 어떤 type을 전달된 것에 한해 받아와서 원하는 일부만 사용할 수 있음

```tsx
{
  type Video = {
    id: string;
    title: string;
    url: string;
    data: string;
  };

  //Video라는 기존의 타입에서 id, title만 이용한 Type을 골라 만들 수 있음
  type VideoMetadata = Pick<Video, "id" | "title">;

  function getVideo(id: string): Video {
    return {
      id,
      title: "video",
      url: "https://..",
      data: "byte-data..",
    };
  }

  function getVideoMetadata(id: string): VideoMetadata {
    return {
      id,
      title: "title",
    };
  }
}

```

## Omit Type

- *pick과 반대로 원하는 것만 제외해서 명세할 수 있음*

```tsx
{
  type Video = {
    id: string;
    title: string;
    url: string;
    data: string;
  };

  // Omit은 전달받은 애들을 제외한 것들을 사용할 수 있음
  type VideoMetadata = Omit<Video, "url" | "data">;

  function getVideo(id: string): Video {
    return {
      id,
      title: "video",
      url: "https://..",
      data: "byte-data..",
    };
  }

  function getVideoMetadata(id: string): VideoMetadata {
    return {
      id,
      title: "title",
    };
  }
}

```